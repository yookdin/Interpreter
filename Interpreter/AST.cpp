//
//  AST.cpp
//  Interpreter
//
//  Created by Yuval Dinari on 7/16/16.
//  Copyright Â© 2016 Vonage. All rights reserved.
//

#include "AST.hpp"


//==========================================================================================================
//==========================================================================================================
void AST::print() {
    recursive_print(0);
}

//==========================================================================================================
//==========================================================================================================
void AST::recursive_print(int indentation_level) {
    cout << setw(indentation_level * 3) << "";
    print_node();
    for(auto& c: children) c->recursive_print(indentation_level + 1);
}


//==========================================================================================================
//==========================================================================================================
int NumAST::extract_num(vector<TokenOrAST>& elements) {
    return ((NumToken*)elements[0].get_token())->val;
}


//==========================================================================================================
//==========================================================================================================
void NumAST::execute() {}


//==========================================================================================================
//==========================================================================================================
BopAST::BopAST(vector<TokenOrAST>& elements): OpAST(elements[1].get_token()->sym, sym_op_map[sym]) {
    add_child(elements[0].get_ast());
    add_child(elements[2].get_ast());
}


//==========================================================================================================
//==========================================================================================================
void BopAST::execute() {}


//==========================================================================================================
//==========================================================================================================
UopAST::UopAST(vector<TokenOrAST>& elements): OpAST(elements[0].get_token()->sym, sym_op_map[sym]) {
    add_child(elements[1].get_ast());
}


//==========================================================================================================
//==========================================================================================================
void UopAST::execute() {}


//==========================================================================================================
//==========================================================================================================
CondExpAST::CondExpAST(vector<TokenOrAST>& elements): OpAST(COND_EXP, sym_op_map[COND_EXP]) {
    add_child(elements[0].get_ast());
    add_child(elements[2].get_ast());
    add_child(elements[4].get_ast());
}


//==========================================================================================================
//==========================================================================================================
void CondExpAST::execute() {}


//==========================================================================================================
//==========================================================================================================
void VarAST::execute() {}


//==========================================================================================================
//==========================================================================================================
AssignmentAST::AssignmentAST(vector<TokenOrAST>& elements): AST(ASSIGN) {
    string id = ((IdentifierToken*)elements[0].get_token())->name;
    add_child(new VarAST(id));
    add_child(elements[2].get_ast());
}


//==========================================================================================================
//==========================================================================================================
void AssignmentAST::execute() {}


//==========================================================================================================
//==========================================================================================================
StatementsAST::StatementsAST(vector<TokenOrAST>& elements): AST(STATEMENTS) {
    // Make children "flat", each shall be an actual statemet and statements nodes will be discarded
    for(auto& e: elements) {
        if(e.is_token) continue; // Probably a semi colon or curly brace
        
        AST* ast = e.get_ast();
        
        if(ast->sym == STATEMENTS)
            for(auto c: ast->children)
                add_child(c);
        else
            add_child(ast);
    }
}


//==========================================================================================================
//==========================================================================================================
void StatementsAST::execute() {}


//==========================================================================================================
// First child will be the expression to evaluate. Rest will be the statements in the body
//==========================================================================================================
IfAST::IfAST(vector<TokenOrAST>& elements): AST(IF) {
    for(int i = 1; i < elements.size(); ++i) { // Skip first element which is the if keyword token
        AST* ast = elements[i].get_ast();
        
        if(ast->sym == STATEMENTS)
            for(auto c: ast->children)
                add_child(c);
        else
            add_child(ast);
    }
}


//==========================================================================================================
//==========================================================================================================
void IfAST::execute() {}





























