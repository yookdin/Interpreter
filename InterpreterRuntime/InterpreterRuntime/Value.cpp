//
//  Value.cpp
//  InterpreterRuntime
//
//  Created by Yuval Dinari on 7/23/16.
//  Copyright Â© 2016 Vonage. All rights reserved.
//

#include <iostream>
using namespace std;

#include "Value.hpp"


//==========================================================================================================
// Global operators of primitives and Value-s
//==========================================================================================================
bool operator<(const int& i, const SharedValue& v) {
    return i < v->to_int();
}

bool operator<(const SharedValue& v, const int& i) {
    return v->to_int() < i;
}

bool operator>(const int& i, const SharedValue& v) {
    return i > v->to_int();
}

bool operator>(const SharedValue& v, const int& i) {
    return v->to_int() > i;
}

bool operator<=(const int& i, const SharedValue& v) {
    return i <= v->to_int();
}

bool operator<=(const SharedValue& v, const int& i) {
    return v->to_int() <= i;
}

bool operator>=(const int& i, const SharedValue& v) {
    return i >= v->to_int();
}

bool operator>=(const SharedValue& v, const int& i) {
    return v->to_int() >= i;
}

bool operator==(const int& i, const SharedValue& v) {
    return i == v->to_int();    
}

bool operator==(const SharedValue& v, const int& i) {
    return v->to_int() == i;
}

bool operator!=(const int& i, const SharedValue& v) {
    return i != v->to_int();
}

bool operator!=(const SharedValue& v, const int& i) {
    return v->to_int() != i;
}


//==========================================================================================================
// The only instance of Value representing a no-value (like null)
//==========================================================================================================
SharedValue no_value(new NoValue); 


/***********************************************************************************************************
 *                                                                                                         *
 *                                       CLASS Value                                                       *
 *                                                                                                         *
 ***********************************************************************************************************/

map<string, Value::CallableFunc> Value::functab = {
    {"type_name",   &Value::type_name}
};


//==========================================================================================================
//==========================================================================================================
string Value::get_type_name(Type type) {
    switch(type) {
        case STRING:          return "STRING";
        case NUMBER:          return "NUMBER";
        case BOOL:            return "BOOL";
        case RANGE:           return "RANGE";
        case LIST:            return "LIST";
        case PARAM_VAL:       return "PARAM_VAL";
        case PARAM_VALS_LIST: return "PARAM_VALS_LIST";
        case MATCH_RESULT:    return "MATCH_RESULT"; 
        case NO_VAL:          return "NO_VAL";
    }
}


//==========================================================================================================
//==========================================================================================================
Value::Type Value::get_type() {
    return type;
}


//==========================================================================================================
//==========================================================================================================
string Value::get_type_name() const {
    return get_type_name(type);
}


//==========================================================================================================
//==========================================================================================================
bool Value::is_no_value() const { 
    return false;
}


//==========================================================================================================
//==========================================================================================================
void Value::print() {
    cout << to_string() << endl;
}


//==========================================================================================================
//==========================================================================================================
SharedValue Value::subscript(int i) const {
    THROW << "Subscript operation not defined for type " << get_type_name();
}


//==========================================================================================================
//==========================================================================================================
SharedValue Value::length(vector<SharedValue> args) {
    THROW << "length() not defined for type " << get_type_name();
}


//==========================================================================================================
//==========================================================================================================
SharedValue Value::match(SharedValue v) const {
    THROW << wrong_op_str("~");
}


//==========================================================================================================
//==========================================================================================================
SharedValue Value::not_match (SharedValue v) const {
    THROW << wrong_op_str("!~");
}


//==========================================================================================================
//==========================================================================================================
int Value::to_int()                const { THROW << "Conversion of " << get_type_name() << " to int is undefined"; }
long Value::to_long()              const { THROW << "Conversion of " << get_type_name() << " to long is undefined"; }
bool Value::to_bool()              const { THROW << "Conversion of " << get_type_name() << " to bool is undefined"; }
vector<string> Value::to_strings() const { THROW << "Conversion of " << get_type_name() << " to vector<string> is undefined"; }


//==========================================================================================================
//==========================================================================================================
SharedValue Value::call_func(string name, vector<SharedValue> args) {
    if(functab.count(name) == 0)
        THROW << "Function " << name << "() not defined for type " << get_type_name();
    else
        return (this->*functab[name])(args);
}


//==========================================================================================================
//==========================================================================================================
SharedValue Value::type_name(vector<SharedValue> args) {
    return SharedValue(new String(get_type_name()));
}


//==========================================================================================================
// Try to convert from string to Value. If can't convert to Bool or Num, it should be a String
//==========================================================================================================
SharedValue Value::from_string(string s) {
    SharedValue val;
    (val = Bool::from_string(s)) or (val = Num::from_string(s)) or (val = List::from_string(s)) or
    (val = String::from_string(s));
    
    return val;
}


//==========================================================================================================
// By default all operators are illeagal. Derived classes will those they support
//==========================================================================================================
Value& Value::operator- ()             const { THROW << wrong_op_str("-");   }
Value& Value::operator+ (Value& other) const { THROW << wrong_op_str("+");   }
Value& Value::operator- (Value& other) const { THROW << wrong_op_str("-");   }
Value& Value::operator* (Value& other) const { THROW << wrong_op_str("*");   }
Value& Value::operator/ (Value& other) const { THROW << wrong_op_str("/");   }
Value& Value::operator% (Value& other) const { THROW << wrong_op_str("%");   }
Value& Value::operator||(Value& other) const { THROW << wrong_op_str("or");  }
Value& Value::operator&&(Value& other) const { THROW << wrong_op_str("and"); }

    
//==========================================================================================================
// Operator 'not' depends on operator bool(). If bool() is defined, so is 'not'.
//==========================================================================================================
Value& Value::operator! () const {
    return *(new Bool(not this->to_bool()));
}

Value& Value::operator==(Value& other) const { THROW << wrong_op_str("==");  }
Value& Value::operator!=(Value& other) const { THROW << wrong_op_str("!=");  }
Value& Value::operator< (Value& other) const { THROW << wrong_op_str("<");   }
Value& Value::operator> (Value& other) const { THROW << wrong_op_str(">");   }
Value& Value::operator<=(Value& other) const { THROW << wrong_op_str("<=");  }
Value& Value::operator>=(Value& other) const { THROW << wrong_op_str(">=");  }
    
    
/***********************************************************************************************************
 *                                                                                                         *
 *                                       CLASS NoValue                                                     *
 *                                                                                                         *
 ***********************************************************************************************************/

//==========================================================================================================
//==========================================================================================================
NoValue::NoValue(): Value(NO_VAL){}


//==========================================================================================================
//==========================================================================================================
Value* NoValue::copy() const { 
    THROW << "NoValue::copy() shouldn't be called";
}


//==========================================================================================================
//==========================================================================================================
bool NoValue::is_no_value() const {
    return true;
}


//==========================================================================================================
//==========================================================================================================
string NoValue::to_string() const { 
    return get_type_name();
}

    
    
    
/***********************************************************************************************************
 *                                                                                                         *
 *                                       CLASS Bool                                                        *
 *                                                                                                         *
 ***********************************************************************************************************/

//==========================================================================================================
//==========================================================================================================
SharedValue Bool::from_string(string s) {
    try {
        bool b = stob(s);
        return SharedValue(new Bool(b));
    } catch(...) {
        return nullptr;
    }
}


//==========================================================================================================
//==========================================================================================================
map<string, Bool::CallableFunc> Bool::functab = {};


//==========================================================================================================
//==========================================================================================================
Bool::Bool(bool _val): Value(BOOL), val(_val) {}


//==========================================================================================================
//==========================================================================================================
void Bool::flip() {
    val = not val;
}


//==========================================================================================================
//==========================================================================================================
bool Bool::to_bool() const { 
    return val;
}

//==========================================================================================================
//==========================================================================================================
string Bool::to_string() const { 
    return ::to_string(val);
}

//==========================================================================================================
//==========================================================================================================
Value& Bool::operator||(Value& other) const { 
    return *(new Bool(val || bool(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& Bool::operator&&(Value& other) const {
    return *(new Bool(val && bool(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& Bool::operator==(Value& other) const {
    return *(new Bool(val == bool(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& Bool::operator!=(Value& other) const {
    return *(new Bool(val != bool(other)));
}

//==========================================================================================================
//==========================================================================================================
Value* Bool::copy() const { 
    return new Bool(val);
}


/***********************************************************************************************************
 *                                                                                                         *
 *                                       CLASS Num                                                         *
 *                                                                                                         *
 ***********************************************************************************************************/

//==========================================================================================================
//==========================================================================================================
SharedValue Num::from_string(string s) {
    try {
        long l = string_to_long(s);
        return SharedValue(new Num(l));
    } catch(...) {
        return nullptr;
    }
}


//==========================================================================================================
//==========================================================================================================
map<string, Num::CallableFunc> Num::functab = {};


//==========================================================================================================
//==========================================================================================================
Num::Num(long _val): Value(NUMBER), val(_val) {}


//==========================================================================================================
//==========================================================================================================
long Num::to_long() const {
    return val;
}

//==========================================================================================================
//==========================================================================================================
int Num::to_int() const { 
    return val;
}

//==========================================================================================================
//==========================================================================================================
string Num::to_string() const { 
    return std::to_string(val);
}

//==========================================================================================================
//==========================================================================================================
Value& Num::operator-() const {
    return *(new Num(-val));
}

//==========================================================================================================
//==========================================================================================================
Value& Num::operator+ (Value& other) const { 
    return *(new Num(val  +  long(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& Num::operator- (Value& other) const { 
    return *(new Num(val  -  long(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& Num::operator* (Value& other) const { 
    return *(new Num(val  *  long(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& Num::operator/ (Value& other) const { 
    return *(new Num(val  /  long(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& Num::operator% (Value& other) const { 
    return *(new Num(val  %  long(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& Num::operator==(Value& other) const { 
    return *(new Bool(val == long(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& Num::operator!=(Value& other) const { 
    return *(new Bool(val != long(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& Num::operator< (Value& other) const { 
    return *(new Bool(val <  long(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& Num::operator> (Value& other) const { 
    return *(new Bool(val >  long(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& Num::operator<=(Value& other) const { 
    return *(new Bool(val <= long(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& Num::operator>=(Value& other) const { 
    return *(new Bool(val >= long(other)));
}


//==========================================================================================================
//==========================================================================================================
Value* Num::copy() const { 
    return new Num(val); 
}



/***********************************************************************************************************
 *                                                                                                         *
 *                                       CLASS String                                                      *
 *                                                                                                         *
 ***********************************************************************************************************/

//==========================================================================================================
//==========================================================================================================
SharedValue String::from_string(string s) {
    return SharedValue(new String(s));
}


//==========================================================================================================
//==========================================================================================================
String::String(string _val): Value(STRING), val(_val) {}


//==========================================================================================================
//==========================================================================================================
String::String(char c): Value(STRING), val(1, c) {}


//==========================================================================================================
//==========================================================================================================
string String::to_string() const {
    return val;
}

//==========================================================================================================
//==========================================================================================================
bool String::to_bool() const { 
    return stob(val);
}

//==========================================================================================================
//==========================================================================================================
long String::to_long() const { 
    return string_to_long(val);
}

//==========================================================================================================
//==========================================================================================================
int String::to_int() const { 
    return string_to_int(val);
}

//==========================================================================================================
//==========================================================================================================
Value& String::operator+ (Value& other) const { 
    return *(new String(val + string(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& String::operator==(Value& other) const {
    return *(new Bool(val == string(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& String::operator!=(Value& other) const {     
    return *(new Bool(val != string(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& String::operator< (Value& other) const { 
    return *(new Bool(val <  string(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& String::operator> (Value& other) const { 
    return *(new Bool(val >  string(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& String::operator<=(Value& other) const { 
    return *(new Bool(val <= string(other)));
}

//==========================================================================================================
//==========================================================================================================
Value& String::operator>=(Value& other) const { 
    return *(new Bool(val >= string(other)));
}

//==========================================================================================================
//==========================================================================================================
SharedValue String::match(SharedValue other) const { 
    return SharedValue(new Bool(regex_match(val, regex(other->to_string()))));
}

//==========================================================================================================
//==========================================================================================================
SharedValue String::not_match(SharedValue other) const { 
    Bool *res = match(other)->get<Bool>();
    res->flip();
    return SharedValue(res);
}

    
//==========================================================================================================
//==========================================================================================================
Value* String::copy() const { 
    return new String(val); 
}


//==========================================================================================================
//==========================================================================================================
SharedValue String::subscript(int i) const {
    if(i >= val.length())
        THROW << "Subscript " << i << " is out of bounds, string length is " << val.length();
        
    return SharedValue(new String(val[i]));
}


//==========================================================================================================
// Script-callable function returning length of the string
//==========================================================================================================
SharedValue String::length(vector<SharedValue> args) {
    return SharedValue(new Num(val.length()));
}


//==========================================================================================================
//==========================================================================================================
SharedValue String::empty(vector<SharedValue> args) {
    return SharedValue(new Bool(val.empty()));
}

    
//==========================================================================================================
//==========================================================================================================
map<string, String::CallableFunc> String::functab = {
    {"length", &String::length},
    {"empty",  &String::empty},
};


/***********************************************************************************************************
 *                                                                                                         *
 *                                       CLASS Range                                                       *
 *                                                                                                         *
 ***********************************************************************************************************/


//==========================================================================================================
//==========================================================================================================
Range::Range(int _s, int _e): Value(RANGE) {
    if(s > e)
        THROW << "Range(): start of range " << s << " is larger than end of range " << e;
    
    s = _s;
    e = _e;
}


//==========================================================================================================
//==========================================================================================================
string Range::to_string() const {
    return "[" + std::to_string(s) + ".." + std::to_string(e) + "]";
 }


//==========================================================================================================
//==========================================================================================================
Value* Range::copy() const {
    return new Range(s, e);
}


//==========================================================================================================
//==========================================================================================================
SharedValue Range::length(vector<SharedValue> args) {
    return SharedValue(new Num(e - s + 1));
}


//==========================================================================================================
//==========================================================================================================
SharedValue Range::subscript(int i) const {
    if(s + i > e)
        THROW << "Range: index " << i << " is out of bounds";
    
    return SharedValue(new Num(s + i));
}


//==========================================================================================================
//==========================================================================================================
map<string, Range::CallableFunc> Range::functab = {
    {"length", &Range::length}
};


/***********************************************************************************************************
 *                                                                                                         *
 *                                       CLASS List                                                        *
 *                                                                                                         *
 ***********************************************************************************************************/


//==========================================================================================================
// Valid string is curly braces containing comma separated values
//==========================================================================================================
SharedValue List::from_string(string s) {
    int i = 0;
    SharedValue res;
    
    try {
        res = from_string(s, i);
    }
    catch(st_exception &exception) {
        // TODO ?
    }
    
    return res;
}


//==========================================================================================================
//==========================================================================================================
map<string, List::CallableFunc> List::functab = {
    {"length", &List::length},
    {"empty",  &List::empty}
};


//==========================================================================================================
//==========================================================================================================
List::List(vector<SharedValue> _values): Value(LIST), values(_values) {} 


//==========================================================================================================
//==========================================================================================================
Value* List::copy() const {
    return new List(values);
}


//==========================================================================================================
//==========================================================================================================
string List::to_string() const {
    string res = "{";
    
    for(auto& val: values)
        res += val->to_string() + ", ";
    
    if(res.length() > 1)
        res.erase(res.length() - 2); // Erase last comma and space
        
    res += "}";
    return res;
}


//==========================================================================================================
//==========================================================================================================
vector<string> List::to_strings() const {
    vector<string> res;
    for(auto& val: values) {
        if(val->get_type() != STRING)
            THROW << FUNC_NAME << ": not all list elements are STRINGs";
       res.push_back((string)*val.get());
    }
    return res;
}


//==========================================================================================================
//==========================================================================================================
SharedValue List::subscript(int i) const {
    if(i >= values.size())
        THROW << "Subscript " << i << " is out of bounds, list size is " << values.size();
    
    return values[i];
}


//==========================================================================================================
// Script-callable function returning length of the list
//==========================================================================================================
SharedValue List::length(vector<SharedValue> args) {
    return SharedValue(new Num(values.size()));
}

    
//==========================================================================================================
//==========================================================================================================
SharedValue List::empty(vector<SharedValue> args) {
    return SharedValue(new Bool(values.empty()));
}


//==========================================================================================================
// Recursive from_string(), to enable lists to include lists. Values can be separated by comma or spaces
//==========================================================================================================
SharedValue List::from_string(string& s, int& i) {
    vector<SharedValue> vals;
    
    if(s[i] != '{')
        THROW << "Can't create list, string doesn't start with '{'";
    
    int value_start = -1;
    bool in_string = false, prev_is_backslash = false, comma_seen = false;
    string bare_string;
    
    //--------------------------------------------------------------------------------------------------
    //--------------------------------------------------------------------------------------------------
    for(++i; i < s.size(); ++i) {

        //----------------------------------------------------------------------------------------------
        // Inside string, look for end of string
        //----------------------------------------------------------------------------------------------
        if(in_string) {
            bool cur_is_backslash = (s[i] == '\\'), cur_is_quote = (s[i] == '"');
                                     
            if(prev_is_backslash or (not cur_is_backslash and not cur_is_quote)) {
                bare_string.push_back(s[i]);
            }
            else if(cur_is_quote) {
                vals.push_back(SharedValue(new String(bare_string)));
                in_string = false;
                bare_string.clear();
            }

            // Turn the flag on only for operator backslash, not for literal one
            prev_is_backslash = (cur_is_backslash and not prev_is_backslash);

            continue;
        }
        
        //----------------------------------------------------------------------------------------------
        // Start of sublist, recurse
        //----------------------------------------------------------------------------------------------
        if(s[i] == '{' and value_start == -1) {
            comma_seen = false;
            vals.push_back(from_string(s, i));
            continue;
        }
        
        //----------------------------------------------------------------------------------------------
        // Beginning of string
        //----------------------------------------------------------------------------------------------
        if(s[i] == '"' and value_start == -1) {
            comma_seen = false;
            in_string = true;
            continue;
        }
        
        //----------------------------------------------------------------------------------------------
        // End of potential value
        //----------------------------------------------------------------------------------------------
        if(s[i] == ' ' or s[i] == ',' or s[i] == '}') {
            
            if(s[i] == ',') {
                if(comma_seen)
                    THROW << "Consecutive commas";
                else
                    comma_seen = true;
            }
            
            if(value_start != -1) { // Found potential value (which isn't string or list)
                string val_str = s.substr(value_start, i - value_start);
                
                SharedValue val = Bool::from_string(val_str);
                if(val) {
                    vals.push_back(val);
                }
                else {
                    val = Num::from_string(val_str);
                    if(val) {
                        vals.push_back(val);
                    }
                    else {
                        THROW << "Can't convert string to value: \"" << val_str << "\"";
                    }
                }
                
                value_start = -1;
            }
            
            if(s[i] == '}') // End of list
                return SharedValue(new List(vals));
            
            continue;
        }
        
        //----------------------------------------------------------------------------------------------
        // Beginning of potential value
        //----------------------------------------------------------------------------------------------
        if(value_start == -1) {
            comma_seen = false;
            value_start = i;
        }
    
    } // for loop
    
    THROW << "Can't create list, string doesn't end with '}'";

} // from_string()


/***********************************************************************************************************
 *                                                                                                         *
 *                                       CLASS ParamVal                                                    *
 *                                                                                                         *
 ***********************************************************************************************************/


//==========================================================================================================
//==========================================================================================================
map<string, ParamVal::CallableFunc> ParamVal::functab = {};


//==========================================================================================================
//==========================================================================================================
ParamVal::ParamVal(string _name, SharedValue _val): Value(PARAM_VAL), name(_name), val(_val) {}


//==========================================================================================================
//==========================================================================================================
ParamVal::ParamVal(string _name, string _val): Value(PARAM_VAL), name(_name), val(new String(_val)) {}


//==========================================================================================================
//==========================================================================================================
ParamVal::ParamVal(string _name, bool _val): Value(PARAM_VAL), name(_name), val(new Bool(_val)) {}


//==========================================================================================================
//==========================================================================================================
Value* ParamVal::copy() const { 
    THROW << "Shouldn't copy a param-value pair"; 
}


//==========================================================================================================
//==========================================================================================================
string ParamVal::to_string() const { 
    return "(" + name + ", " + val->to_string() + ")"; 
}



/***********************************************************************************************************
 *                                                                                                         *
 *                                       CLASS ParamValsList                                               *
 *                                                                                                         *
 ***********************************************************************************************************/

map<string, ParamValsList::CallableFunc> ParamValsList::functab = {
    {"length", &ParamValsList::length},
    {"empty",  &ParamValsList::empty}
};


//==========================================================================================================
//==========================================================================================================
ParamValsList::ParamValsList(vector<SharedValue> _values): Value(PARAM_VALS_LIST) {
    for(auto v: _values) {
        if(v->get_type() != PARAM_VAL)
           THROW << "All values of ParamValsList should be param-vals";
        
        values.push_back(v);
    }
} 


//==========================================================================================================
//==========================================================================================================
Value* ParamValsList::copy() const {
    return new ParamValsList(values);
}


//==========================================================================================================
//==========================================================================================================
string ParamValsList::to_string() const {
    string res = "(";
    
    for(auto& val: values)
        res += val->to_string() + ", ";
    
    if(res.length() > 1)
        res.erase(res.length() - 2); // Erase last comma and space
        
        res += ")";
    return res;
}


//==========================================================================================================
//==========================================================================================================
vector<SharedValue> ParamValsList::get_values() {
    return values;
}


//==========================================================================================================
//==========================================================================================================
SharedValue ParamValsList::subscript(int i) const {
    if(i >= values.size())
        THROW << "Subscript " << i << " is out of bounds, list size is " << values.size();
    
    return values[i];
}


//==========================================================================================================
// Script-callable function returning length of the list
//==========================================================================================================
SharedValue ParamValsList::length(vector<SharedValue> args) {
    return SharedValue(new Num(values.size()));
}

    
//==========================================================================================================
//==========================================================================================================
SharedValue ParamValsList::empty(vector<SharedValue> args) {
    return SharedValue(new Bool(values.empty()));
}


/***********************************************************************************************************
 *                                                                                                         *
 *                                       CLASS MatchResult                                                 *
 *                                                                                                         *
 ***********************************************************************************************************/


map<string, MatchResult::CallableFunc> MatchResult::functab = {
    {"length", &MatchResult::length},
    {"empty", &MatchResult::empty}
};

//==========================================================================================================
// Note: smatch contains references to the original string on which the match was performed. So can't just
// do a match somewhere and pass the smatch around. Better to give the string and regex to MatchResult, and
// have it perform the match and store the original string, so that the match result is valid as long as the
// instance exists.
//==========================================================================================================
MatchResult::MatchResult(string _str, string _regex_str): Value(MATCH_RESULT), str(_str), regex_str(_regex_str) {
    regex_match(str, match, regex(regex_str));
}


//==========================================================================================================
//==========================================================================================================
Value* MatchResult::copy() const {
    return new MatchResult(str, regex_str);
}


//==========================================================================================================
//==========================================================================================================
string MatchResult::to_string() const {
    return "MatchResult";
}


//==========================================================================================================
//==========================================================================================================
SharedValue MatchResult::subscript(int i) const {
    if(i >= match.size())
        THROW << "Subscript " << i << " is out of bounds, number of submatches is " << match.size();
    
    return SharedValue(new String(match[i].str()));
}


//==========================================================================================================
// Script-callable function returning number of matches
//==========================================================================================================
SharedValue MatchResult::length(vector<SharedValue> args) {
    return SharedValue(new Num(match.size()));
}


//==========================================================================================================
//==========================================================================================================
SharedValue MatchResult::empty(vector<SharedValue> args) {
    return SharedValue(new Bool(match.empty()));
}








